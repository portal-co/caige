{"mappings":"ACCO,SAAS,0CAAO,EAAe;IAClC,OAAO,CAAC;;;;;;AAMZ,CAAC;AACD;;;ADNO,MAAM;IACT,CAAA,MAAO,CAAI;IACX,CAAA,IAAK,CAAU;IACf,IAAI,SAAY;QACZ,OAAO,IAAI,CAAC,CAAA,MAAO;IACvB;IACA,IAAI,OAAgB;QAChB,OAAO,IAAI,CAAC,CAAA,IAAK;IACrB;IAEA,YAAY,UAAE,MAAM,QAAE,IAAI,EAAgC,CAAE;QACxD,IAAI,CAAC,CAAA,MAAO,GAAG;QACf,IAAI,CAAC,CAAA,IAAK,GAAG;IACjB;AACJ;AAQO,MAAM;IACT,CAAA,GAAI,CAAM;IACV,YAAY,OAAE,GAAG,EAAgB,CAAE;QAC/B,IAAI,CAAC,CAAA,GAAI,GAAG;IAChB;IACA,CAAA,eAAgB,CAAC,EAAwB;QAErC,OAAO,OAAO,SAAS,GAAG;YACtB,oBAAoB,OAAU;gBAC1B,MAAM,UAAU,MAAM,IAAI,CAAC,CAAA,GAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAK,EAAE,CAAC;gBACrD,IAAI,kBAAkB;gBACtB,MAAM,aAAa;gBACnB,IAAI,OAAO,MAAM,QAAQ,IAAI,CAAC;oBAC1B,MAAM;wBACF,IAAI,MAAM;4BACN,MAAM,MAAM,QAAQ,KAAK,CAAC,GAAG,MAAM,CAAC,CAAC,MAAM,KAAK,IAAM,GAAG,OAAO,IAAI,CAAC,EAAE,YAAY,6CAAQ,YAAY,IAAI,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,cAAc,EAAE,kBAAkB,MAAM,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,KAAK,EAAE,OAAO,CAAC,EAAE;4BAClM,OAAO;4BACP,OAAO;wBACX,OACI,OAAO;oBAEf;gBACJ;gBACA,IAAI,iBAAiB;oBACjB,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IACnC,IAAI,IAAI,CAAC,EAAE,YAAY,6CAAQ,YAAY,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE;wBACrD,MAAM,cAAc,CAAC,cAAc,EAAE,EAAE,GAAG,CAAC;wBAC3C,IAAI,OAAO;wBACX,OAAO,KAAK,OAAO,CAAC,IAAI,OAAO,GAAG,YAAY,WAAW,CAAC,GAAG,CAAC,GAAG;4BAC7D,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC;4BACpB,OAAO;4BACP,OAAO;wBACX;wBACA,IAAI,CAAC,MACD,SAAS;oBAEjB;oBAEJ,OAAO;gBACX,OACI,OAAO;YAEf;QACJ;IACJ;IACA,IAAI,kBAAkB;QAClB,OAAO,CAAA,MAAO,IAAI,CAAC,CAAA,eAAgB,CAAC;IACxC;AACJ","sources":["index.ts","prompt.ts"],"sourcesContent":["import { StandardSchemaV1 } from \"@standard-schema/spec\"\nimport { prompt } from \"./prompt.ts\";\nexport type Kind<T> = { output(value: T): void } | { input: T };\nexport class Slot<T, S extends StandardSchemaV1<unknown, T>> {\n    #schema: S;\n    #kind: Kind<T>;\n    get schema(): S {\n        return this.#schema;\n    }\n    get kind(): Kind<T> {\n        return this.#kind;\n    }\n\n    constructor({ schema, kind }: { schema: S, kind: Kind<T> }) {\n        this.#schema = schema;\n        this.#kind = kind;\n    }\n}\nexport interface LLM {\n    startSession(system: string): Promise<LLMSession>\n}\nexport interface LLMSession {\n    chat(iter: { next(): Promise<string | null> }): Promise<string>\n}\nexport type NaturalFunctionArgs = {};\nexport class LLMPool {\n    #llm: LLM;\n    constructor({ llm }: { llm: LLM }) {\n        this.#llm = llm;\n    }\n    #naturalFunction({ }: NaturalFunctionArgs): (strings: TemplateStringsArray, ...args: any[]) => Promise<string> {\n\n        return async (strings, ...args) => {\n            llmDesiredResponse: for (; ;) {\n                const session = await this.#llm.startSession(prompt({}));\n                let placeholderMode = false;\n                const argsBackup = args;\n                let resp = await session.chat({\n                    async next() {\n                        if (args) {\n                            const str = strings.slice(1).reduce((prev, cur, i) => `${prev}${args[i] instanceof Slot && 'output' in args[i].kind ? `{{placeholder ${placeholderMode = true, i}}}` : args[i]}${cur}`, strings[0]);\n                            args = null;\n                            return str;\n                        } else {\n                            return null;\n                        }\n                    }\n                });\n                if (placeholderMode) {\n                    for (let i = 0; i < argsBackup.length; i++) {\n                        if (args[i] instanceof Slot && 'output' in args[i].kind) {\n                            const placeholder = `{{placeholder ${i}}}:`;\n                            let done = false;\n                            resp = resp.replace(new RegExp(`${placeholder}:([^\\n]*)\\n`), (s, resp) => {\n                                args[i].kind.output(resp);\n                                done = true;\n                                return \"\";\n                            });\n                            if (!done) {\n                                continue llmDesiredResponse;\n                            }\n                        }\n                    }\n                    return resp;\n                } else {\n                    return resp;\n                }\n            }\n        }\n    }\n    get naturalFunction() {\n        return arg => this.#naturalFunction(arg);\n    }\n}","export type PromptArgs = {};\nexport function prompt({ }: PromptArgs): string {\n    return `\nYou are a Large Language Model agent who answers questions. You generate short (preferably a few words), consistent, responses to queries as they are part of a larger application. If the query is a statement, and it contains {{placeholders}}, write answers which would replace them out in the following format:\n\n{{placeholder}}: answer\n\nRemember to keep answers brief and consistent, regardless of whether they are to a question or a filled-in placeholder.\n`\n}"],"names":[],"version":3,"file":"index.js.map"}